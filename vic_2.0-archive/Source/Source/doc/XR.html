<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><meta http-equiv="content-type" content="text/html; charset=windows-1252"><title>Expressions rationnelles - Guide</title><meta http-equiv="content-style-type" content="text/css"><style type="text/css" media="all">a{text-decoration:underline}a:link{color:blue}a:visited{color:purple}abbr{border-bottom:1px dotted #000;cursor:help}body{background:#fff;color:#333;font:.85em/1.5 verdana,arial,helvetica;margin:0 auto;padding:20px;max-width:1024px}h1{margin:0}h2,h3{margin-bottom:-.5em}h1,h2,h3{color:#d10000}h2{border-bottom:1px solid}ol,p,ul{margin-bottom:1.5em}pre{font:1em/1.6 consolas,monospace;margin:0}table{border:1px solid #999;border-width:1px 1px 1px 0;font:1em/1.5 verdana,arial,helvetica,sans-serif;margin:1.3em 0;width:100%}td,th{border:1px solid #999;border-width:0 0 0 1px;padding:3px 6px;vertical-align:top}th{background:#405871;color:#fff}tt,tt span{background:#ff9;color:#000;font:1em/1.5 consolas,monospace;white-space:pre}.col1{width:20%}.col2{width:60%}.impair{background:#eee}.match{background:#e8f4ff;border:1px solid #0066ff;border-width:1px 0}.nomatch{background:#eee0ee;border:1px solid #ff00ff;border-width:1px 0}.regex{background:#fff4e8;border:1px solid #ff6600;border-width:1px 0}.string{background:#e0ffe0;border:1px solid #00a000;border-width:1px 0}.plage{background:#94fe86}</style><body lang="fr"><h1>Expressions rationnelles - Guide</h1><p><a href="#metacaracteres">Les métacaractères</a> • <a href="#quantificateurs">Les quantificateurs</a> • <a href="#ancres">Les ancres</a> • <a href="#classes">Les classes</a> • <a href="#groupes">Les groupes</a> • <a href="#options">Les options</a> • <a href="#renvois">Les renvois</a> • <a href="#comportements">Les comportements</a><h2 id=metacaracteres>Les métacaractères</h2><p>Les caractères <tt>[\^$.|?*+()</tt> ont un sens spécial. Ils sont pris littéralement lorsqu'échappés avec <tt>\</tt> ou délimités par <tt>\Q</tt> et <tt>\E</tt> (de l'anglais <i lang=en>Quote</i>). Tout autre caractère vaut pour lui-même. Exemples : <tt class=regex>1\+1=2</tt> trouve <tt class=match>1+1=2</tt>, tandis que <tt class=regex>\(\\\?\)</tt> et <tt class=regex>\Q(\?)\E</tt> trouvent <tt class=match>(\?)</tt>.<p>Le <b>point</b> <tt>.</tt> vaut n'importe quel caractère, sauf une fin de ligne. Exemple : <tt class=regex>r.se</tt> trouve <tt class=match>rose</tt>, <tt class=match>rase</tt> ou <tt class=match>ruse</tt>. La <b>barre verticale</b> <tt>|</tt> sépare des alternatives. Exemples : <tt class=regex>a|b</tt> trouve <tt class=match>a</tt> ou <tt class=match>b</tt>, tandis que <tt class=regex>abc|123</tt> trouve <tt class=match>abc</tt> ou <tt class=match>123</tt>. Les signes <tt>?*+</tt> servent de <a href="#quantificateur">quantificateurs</a>, les signes <tt>^$</tt> servent d'<a href="#ancre">ancres</a>, le <b>crochet ouvrant</b> <tt>[</tt> ouvre une <a href="#classe">classe</a>, et les <b>parenthèses</b> <tt>()</tt> servent à délimiter un <a href="#groupe">groupe</a>. La <b>barre oblique inverse</b> <tt>\</tt> sert à échapper un métacaractère, et à constituer chacun des caractères spéciaux suivants :<table cellspacing="0"><tr><th>Caractère<th>Explication<tr class=impair><td><tt>\1</tt> à <tt>\9</tt><td>Retourne le contenu mémorisé d'un groupe. Par exemple : <tt class=regex>([0-9])\1</tt> trouve <tt class=match>00</tt>, <tt class=match>11</tt>, <tt class=match>22</tt>, etc.<tr><td><tt>\a</tt><td>Bip système. Caractère ASCII numéro 7.<tr class=impair><td><tt>\A</tt><td>Ancre le motif au début de la chaîne, strictement. Exemple : <tt class=regex>\A123</tt> trouve <tt class=match>123</tt> dans <tt class=string>123abc</tt>, mais pas dans <tt class=string>\n123abc</tt>.<tr><td><tt>\b</tt><td>Trouve la position entre <tt>\w</tt> et <tt>\W</tt>, ou entre <tt>\w</tt> et une extrémité de la chaîne. Dans une classe, <tt>\b</tt> est un retour arrière.<tr class=impair><td><tt>\B</tt><td>Contraire de <tt>\b</tt>. Trouve la position entre <tt>\w</tt> et <tt>\w</tt>, ou entre <tt>\W</tt> et <tt>\W</tt>.<tr><td><tt>\cA</tt> à <tt>\cZ</tt><td>Réfère aux 26 premiers caractères ASCII. Il s'agit des codes ^A à ^Z.<tr class=impair><td><tt>\d</tt><td>Abréviation de <tt class=regex>[0-9]</tt>. Trouve un chiffre.<tr><td><tt>\D</tt><td>Abréviation de <tt class=regex>[^0-9]</tt>. Trouve tout caractère qui n'est pas un chiffre.<tr class=impair><td><tt>\e</tt><td>Échappement. Caractère ASCII numéro 27.<tr><td><tt>\E</tt><td>Annonce la fin d'une séquence littérale. Voir <tt>\Q</tt>.<tr class=impair><td><tt>\f</tt><td>FF (<i lang="en">Form Feed</i>). Caractère ASCII numéro 12. Fait partie des caractères de fin de ligne.<tr><td><tt>\G</tt><td>Ancre d'abord le motif au début de la chaîne, puis au début de chaque correspondance trouvée.<tr class=impair><td><tt>\K</tt><td>Occulte la partie de la correspondance située à gauche. Exemple : <tt class=regex>ab\Kcd</tt> trouve <tt class=match>abcd</tt>, mais rapporte <tt class=match>cd</tt>.<tr><td><tt>\n</tt><td>LF (<i lang="en">Line Feed</i>). Caractère ASCII numéro 10. Correspond à une fin de ligne de type Unix.<tr class=impair><td><tt>\Q</tt><td>Annonce le début d'une séquence littérale. Exemple : <tt class=regex>\Q+-*/\E</tt> trouve <tt class=match>+-*/</tt>.<tr><td><tt>\r</tt><td>CR (<i lang="en">Carriage Return</i>). Caractère ASCII numréo 13. Correspond à une fin de ligne de type Mac.<tr class=impair><td><tt>\R</tt><td>N'importe quel caractère de fin de ligne. Trouve <tt><abbr lang="en" title="Line Feed">LF</abbr></tt>, <tt><abbr title="Vertical Tab">VT</abbr></tt>, <tt><abbr title="Form Feed">FF</abbr></tt> et <tt><abbr lang="en" title="Carriage Return">CR</abbr></tt>.<tr><td><tt>\s</tt><td>Abréviation de <tt class=regex>[\t\n\r ]</tt>. Trouve tab, <tt><abbr lang="en" title="Line Feed">LF</abbr></tt>, <tt><abbr lang="en" title="Carriage Return">CR</abbr></tt> ou espace.<tr class=impair><td><tt>\S</tt><td>Abréviation de <tt class=regex>[^\t\n\r ]</tt>. Trouve tout caractère sauf tab, <tt><abbr lang="en" title="Line Feed">LF</abbr></tt>, <tt><abbr lang="en" title="Carriage Return">CR</abbr></tt> et espace.<tr><td><tt>\t</tt><td>Tabulation. Caractère ASCII numéro 9.<tr class=impair><td><tt>\v</tt><td>VT (<i lang="en">Vertical Tab</i>). Caractère ASCII numéro 11. Fait partie des caractères de fin de ligne.<tr><td><tt>\w</tt><td>Abréviation de <tt class=regex>[a-zA-Z0-9_]</tt>. Trouve une lettre, un chiffre ou un soulignement.<tr class=impair><td><tt>\W</tt><td>Abréviation de <tt class=regex>[^a-zA-Z0-9_]</tt>. Trouve tout caractère sauf une lettre, un chiffre ou un soulignement.<tr><td><tt>\xFF</tt><td>Trouve le caractère ASCII/ANSI numéro FF, exprimé en hexadécimal. Exemple : <tt class=regex>\x80\$\xA5</tt> trouve <tt class=match>€$¥</tt>.<tr class=impair><td><tt>\z</tt><td>Ancre le motif à la fin de la chaîne, strictement. Exemple : <tt class=regex>jkl\z</tt> trouve <tt class=match>jkl</tt> dans <tt class=string>123jkl</tt>, mais pas dans <tt class=nomatch>123jkl\n</tt>.<tr><td><tt>\Z</tt><td>Ancre le motif à la fin de la chaîne, ou devant un caractère de fin de ligne en fin de fichier. Exemple : <tt class=regex>456\Z</tt> trouve <tt class=match>456</tt> aussi bien dans <tt class=string>jkl456</tt> que dans <tt class=string>jkl456\n</tt>, mais pas dans <tt class=nomatch>jkl456\nabc</tt> .</table><h2 id=quantificateurs>Les quantificateurs</h2><p>Déterminent la répétition d'un caractère <tt>…</tt>, d'un caractère spécial <tt>\…</tt>, d'un groupe <tt>(…)</tt> ou d'une classe <tt>[…]</tt>. On les met à la droite immédiate de l'item auquel ils se rapportent. Par défaut, leur comportement est <b>vorace</b>. En voici la liste complète :<table cellspacing="0"><tr><th>Signe<th>Explication<th>Exemple<tr class=impair><td><tt>{m,n}</tt><td>Trouve entre <tt>m</tt> et <tt>n</tt> fois l'item affecté <tt>(n &ge; m &ge; 0)</tt>. On écrit <tt class=regex>{m,}</tt> lorsqu'il n'y a pas de limite supérieure, et on abrège avec <tt class=regex>{m}</tt> lorsque <tt>m = n</tt>.<td><tt class=regex>a{2,3}</tt> trouve <tt class=match>aa</tt> ou <tt class=match>aaa</tt> seulement<tr><td><tt>?</tt><td>Trouve 0 ou 1 fois l'item affecté. Équivaut à <tt class=regex>{0,1}</tt>. Rend un quantificateur <b>frugal</b> lorsque situé à sa droite. Par exemple : <tt>??</tt>, <tt>*?</tt>, <tt>+?</tt> et <tt>{m,n}?</tt> ont un comportement frugal.<td><tt class=regex>abc?</tt> trouve <tt class=match>ab</tt> ou <tt class=match>abc</tt> seulement<tr class=impair><td><tt>+</tt><td>Trouve 1 ou plusieurs fois l'item affecté. Équivaut à <tt class=regex>{1,}</tt>. Rend un quantificateur <b>possessif</b> lorsque situé à sa droite. Par exemple : <tt>?+</tt>, <tt>*+</tt>, <tt>++</tt> et <tt>{m,n}+</tt> ont un comportement possessif.<td><tt class=regex>abc+</tt> trouve <tt class=match>abc</tt> ou <tt class=match>abcc</tt>, <tt class=match>abccc</tt>, etc.<tr><td><tt>*</tt><td>Trouve 0 ou plusieurs fois l'item affecté. Équivaut à <tt class=regex>{0,}</tt>.<td><tt class=regex>abc*</tt> trouve <tt class=match>ab</tt> ou <tt class=match>abc</tt>, <tt class=match>abcc</tt>, etc.</table><h2 id=ancres>Les ancres</h2><p>Les ancres ont en commun de chercher une correspondance par rapport à une <b>position</b> et non par rapport à un caractère. Le tableau suivant en dresse la liste complète :<table cellspacing="0"><tr><th>Ancre<th>Explication<th>Exemple<tr class=impair><td><tt>^</tt><td>Ancre le motif au début de la chaîne, ainsi qu'après une fin de ligne lorsque l'option <tt>m</tt> est activée.<td><tt class=regex>m)^abc</tt> trouve <tt class=match>abc</tt> dans <tt class=string>abc123</tt> ou dans <tt class=string>123\nabc</tt>, mais pas dans <tt class=nomatch>123abc123</tt><tr><td><tt>$</tt><td>Ancre le motif à la fin de la chaîne, ainsi qu'avant une fin de ligne lorsque l'option <tt>m</tt> est activée.<td><tt class=regex>m)abc$</tt> trouve <tt class=match>abc</tt> dans <tt class=string>123abc</tt> ou dans <tt class=string>abc\n123</tt>, mais pas dans <tt class=nomatch>123abc123</tt><tr class=impair><td><tt>\A</tt><td>Ancre le motif au début de la chaîne, strictement.<td><tt class=regex>\A123</tt> trouve <tt class=match>123</tt> dans <tt class=string>123abc</tt>, mais jamais dans <tt class=string>\n123abc</tt>.<tr><td><tt>\z</tt><td>Ancre le motif à la fin de la chaîne, strictement.<td><tt class=regex>jkl\z</tt> trouve <tt class=match>jkl</tt> dans <tt class=string>123jkl</tt>, mais jamais dans <tt class=nomatch>123jkl\n</tt>.<tr class=impair><td><tt>\Z</tt><td>Ancre le motif à la fin de la chaîne, ou devant un caractère de fin de ligne en fin de fichier.<td><tt class=regex>456\Z</tt> trouve <tt class=match>456</tt> aussi bien dans <tt class=string>jkl456</tt> que dans <tt class=string>jkl456\n</tt>, mais pas dans <tt class=nomatch>jkl456\nabc</tt></table><p>L'option <tt>m</tt> n'a aucune influence sur le comportement des ancres <tt>\A</tt>, <tt>\z</tt> et <tt>\Z</tt>. Le caractère spécial <tt>\G</tt> ancre d'abord le motif au début de la chaîne, puis au début de chaque correspondance trouvée. Par exemple : <tt class=regex>\G\d{2}</tt> appliquée à <tt class=string>1234,56</tt> trouve <tt class=match>12</tt>, puis <tt class=match>23</tt>, puis <tt class=match>34</tt>, et échoue ensuite à trouver <tt class=nomatch>56</tt>.<h2 id=classes>Les classes</h2><p>Énumère des caractères ou plages de caractères. Par exemple : <tt class=regex>[abc]</tt> trouve <tt class=match>a</tt>, <tt class=match>b</tt> ou <tt class=match>c</tt>, alors que <tt class=regex>[a-zA-Z0-9]</tt> trouve une lettre ou un chiffre. Les signes <tt>^-]\</tt> ont un sens spécial. Pour les prendre tel quel, on peut les échapper avec <tt>\</tt> ou les placer à un endroit précis comme on l'explique dans le tableau suivant :<table cellspacing="0"><tr><th>Signe<th>Explication<th>Exemple<tr class=impair><td><tt>^</tt><td>Inverse la classe lorsque situé immédiatement à droite de <tt>[</tt>. Vaut pour lui-même partout ailleurs.<td><tt class=regex>[a^]</tt> trouve <tt class=match>a</tt> ou <tt class=match>^</tt>, tandis que <tt class=regex>[^a]</tt> trouve n'importe quel caractère sauf <tt class=nomatch>a</tt><tr><td><tt>-</tt><td>Sépare les deux extrémités d'une plage de caractères, sauf lorsque placé immédiatement après <tt>[</tt> et <tt>[^</tt>, ou avant <tt>]</tt>.<td><tt class=regex>[1-3]</tt> trouve <tt class=match>1</tt>, <tt class=match>2</tt> ou <tt class=match>3</tt>, tandis que <tt class=regex>[-13]</tt> trouve <tt class=match>-</tt>, <tt class=match>1</tt> ou <tt class=match>3</tt><tr class=impair><td><tt>]</tt><td>Annonce la fermeture d'une classe de caractères, sauf lorsque placé immédiatement après <tt>[</tt> ou <tt>[^</tt>.<td><tt class=regex>[ab]]</tt> trouve <tt class=match>a]</tt> ou <tt class=match>b]</tt>, tandis que <tt class=regex>[]ab]</tt> trouve <tt class=match>]</tt>, <tt class=match>a</tt> ou <tt class=match>b</tt><tr><td><tt>\</tt><td>Permet d'échapper le signe situé immédiatement après, y compris lorsqu'il s'agit de lui-même.<td><tt class=regex>[\[?\]\\]</tt> trouve <tt class=match>[</tt>, <tt class=match>?</tt>, <tt class=match>]</tt> ou <tt class=match>\</tt></table><p>Les métacaractères <tt>[$.|?*+()</tt> n'ont pas besoin d'être échappés dans une classe. Pour cibler d'un coup plusieurs caractères ou plages de caractères, on peut utiliser les formes <tt>[[:mot:]]</tt> ou <tt>[^[:mot:]]</tt> avec les valeurs de mots suivantes. On a indiqué les expressions plus brèves existantes, le cas échéant.<table cellspacing=0><thead><tr><th>Mot<th>Énumération des caractères ciblés<th>Abrév.<tbody style="font:1em consolas,monospace;letter-spacing:-1px"><tr class=impair><td><tt>alnum</tt><td>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./<tt class=plage>0123456789</tt>:;&lt;=>?@<tt class=plage>ABCDEFGHIJKLMNOPQRSTUVWXYZ</tt>[\]^_`<tt class=plage>abcdefghijklmnopqrstuvwxyz</tt>{|}~DEL<td><tr><td><tt>alpha</tt><td>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./0123456789:;&lt;=>?@<tt class=plage>ABCDEFGHIJKLMNOPQRSTUVWXYZ</tt>[\]^_`<tt class=plage>abcdefghijklmnopqrstuvwxyz</tt>{|}~DEL<td><tt class=regex>i)[a-z]</tt><tr class=impair><td><tt>ascii</tt><td><tt class=plage>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./0123456789:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~DEL</tt><td><tr><td><tt>blank</tt><td>0-8<tt class=plage>\t</tt>\n\v\f\r14-31<tt class=plage> </tt>!"#$%&amp;'()*+,-./0123456789:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~DEL<td><tr class=impair><td><tt>cntrl</tt><td><tt class=plage>0-8\t\n\v\f\r14-31</tt> !"#$%&amp;'()*+,-./0123456789:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~<tt class=plage>DEL</tt><td><tr><td><tt>digit</tt><td>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./<tt class=plage>0123456789</tt>:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~DEL<td><tt class=regex>\d</tt><tr class=impair><td><tt>graph</tt><td>0-8\t\n\v\f\r14-31 <tt class=plage>!"#$%&amp;'()*+,-./0123456789:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</tt>DEL<td><tr><td><tt>lower</tt><td>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./0123456789:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`<tt class=plage>abcdefghijklmnopqrstuvwxyz</tt>{|}~DEL<td><tt class=regex>[a-z]</tt><tr class=impair><td><tt>print</tt><td>0-8\t\n\v\f\r14-31<tt class=plage> !"#$%&amp;'()*+,-./0123456789:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</tt>DEL<td><tr><td><tt>punct</tt><td>0-8\t\n\v\f\r14-31 <tt class=plage>!"#$%&amp;'()*+,-./</tt>0123456789<tt class=plage>:;&lt;=>?@</tt>ABCDEFGHIJKLMNOPQRSTUVWXYZ<tt class=plage>[\]^_`</tt>abcdefghijklmnopqrstuvwxyz<tt class=plage>{|}~</tt>DEL<td><tr class=impair><td><tt>space</tt><td>0-8<tt class=plage>\t\n\v\f\r</tt>14-31<tt class=plage> </tt>!"#$%&amp;'()*+,-./0123456789:;&lt;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~DEL<td><tt class=regex>\s</tt><tr><td><tt>upper</tt><td>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./0123456789:;&lt;=>?@<tt class=plage>ABCDEFGHIJKLMNOPQRSTUVWXYZ</tt>[\]^_`abcdefghijklmnopqrstuvwxyz{|}~DEL<td><tt class=regex>[A-Z]</tt><tr class=impair><td><tt>word</tt><td>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./<tt class=plage>0123456789</tt>:;&lt;=>?@<tt class=plage>ABCDEFGHIJKLMNOPQRSTUVWXYZ</tt>[\]^<tt class=plage>_</tt>`<tt class=plage>abcdefghijklmnopqrstuvwxyz</tt>{|}~DEL<td><tt class=regex>\w</tt><tr><td><tt>xdigit</tt><td>0-8\t\n\v\f\r14-31 !"#$%&amp;'()*+,-./<tt class=plage>0123456789</tt>:;&lt;=>?@<tt class=plage>ABCDEF</tt>GHIJKLMNOPQRSTUVWXYZ[\]^_`<tt class=plage>abcdef</tt>ghijklmnopqrstuvwxyz{|}~DEL<td></table><p><b>alnum</b> = [digit + alpha]; <b>alpha</b> = [upper + lower]; <b>ascii</b> = [cntrl + print]; <b>print</b> = [espace + graph]; <b>word</b> = [alnum + soulignement].<h2 id=groupes>Les groupes</h2><p>Les groupes peuvent prendre des formes nombreuses et variées. On les a répartis en 3 familles distinctes par pure commodité.<h3>Les groupes simples</h3><table cellspacing="0"><tr><th>Forme<th>Explication<th>Exemple<tr class=impair><td><tt>(regex)</tt><td><b>Normal</b>. Mémorise la correspondance et la numérote de manière à pouvoir y référer avec <tt>\1</tt>.<td><tt class=regex>(ab)c\1</tt> trouve <tt class=match>abcab</tt> après avoir mémorisé <tt class=match>ab</tt><tr><td><tt>(?:regex)</tt><td><b>Amnésique</b>. Permet de délimiter un groupe sans mémoriser la correspondance.<td><tt class=regex>(?:ab){2}</tt> trouve <tt class=match>abab</tt>, mais ne mémorise rien<tr class=impair><td><tt>(?#…)</tt><td><b>Commentaire</b>. Permet d'inscrire un contenu qui sera ignoré par l'engin de recherche.<td><tt class=regex>a(?# Note quelconque)bc</tt> trouve <tt class=match>abc</tt><tr><td><tt>(?…:regex)</tt><td><b>À option</b>. Applique une ou plusieurs options au groupe, sans affecter la suite de l'expression rationnelle.<td><tt class=regex>(?i:a)b</tt> trouve <tt class=match>ab</tt> ou <tt class=match>Ab</tt>, mais ni <tt class=nomatch>aB</tt> ni <tt class=nomatch>AB</tt><tr class=impair><td><tt>(?>regex)</tt><td><b>Atomique</b>. Une fois le groupe satisfait, ne permet pas à l'engin de recherche de rebrousser chemin vers lui pour tenter d'autres permutations.<td><tt class=regex>a(bc|b)c</tt> trouve <tt class=match>abcc</tt> ou <tt class=match>abc</tt>, alors que <tt class=regex>a(?>bc|b)c</tt> trouve <tt class=match>abcc</tt>, mais pas <tt class=nomatch>abc</tt><tr><td><tt>(?P&lt;nom>regex)</tt><td><b>Nommé</b>. Affecte un nom au groupe constitué; nom qu'on pourra utiliser comme référence lors d'un renvoi.<td>Si <tt class=regex>.+?(?P&lt;nb>\d+)</tt> et <tt class=string>abc123</tt>; alors <tt class=regex>${nb}</tt> restitue <tt class=match>123</tt></table><h3>Les groupes assertifs</h3><table cellspacing="0"><tr><th>Forme<th>Explication<th>Exemple<tr class=impair><td><tt>(?=regex)</tt><td><b>Regard avant positif</b>. Établit une correspondance en fonction de ce qui doit exister après elle.<td><tt class=regex>t(?=e)</tt> trouve le 1er <tt class=match>t</tt> dans <tt class=string><span>t</span>estée</tt><tr><td><tt>(?!regex)</tt><td><b>Regard avant négatif</b>. Établit une correspondance en fonction de ce qui ne doit pas exister après elle.<td><tt class=regex>t(?!e)</tt> trouve le 2e <tt class=match>t</tt> dans <tt class=string>tes<span>t</span>ée</tt><tr class=impair><td><tt>(?&lt;=regex)</tt><td><b>Regard arrière positif</b>. Tente d'établir une correspondance en fonction de ce qui existe avant la position courante.<td><tt class=regex>(?<=s)t</tt> trouve le 2e <tt class=match>t</tt> dans <tt class=string>tes<span>t</span>ée</tt><tr><td><tt>(?&lt;!regex)</tt><td><b>Regard arrière négatif</b>. Tente d'établir une correspondance en fonction de ce qui n'existe pas avant la position courante.<td><tt class=regex>(?&lt;!s)t</tt> trouve le 1er <tt class=match>t</tt> dans <tt class=string><span>t</span>estée</tt></table><h3>Les groupes conditionnels</h3><table cellspacing="0"><tr><th>Forme<th>Explication<th>Exemple<tr><td><tt>(?(?=regex)alors|sinon)</tt><td><b>Groupe conditionnel simple</b>. Applique la première ou la deuxième partie, selon qu'une correspondance à l'expression rationnelle est trouvée ou pas. Les 4 formes de regard avant ou arrière sont admises.<td><tt class=regex>(?(?&lt;=a)b|c)</tt> trouve le 2e <tt class=match>b</tt> et le 1er <tt class=match>c</tt> dans <tt class=string>ba<span>b</span>x<span>c</span>ac</tt><tr class=impair><td><tt>(?(1)alors|sinon)</tt><td><b>Groupe conditionnel à référence numérotée</b>. Applique la première ou la deuxième partie, selon que le groupe numéroté existe en mémoire ou pas.<td><tt class=regex>(a)?(?(1)b|c)</tt> trouve <tt class=match>ab</tt>, et les 1er et 2e <tt class=match>c</tt> dans <tt class=string>b<span>ab</span>x<span>c</span>a<span>c</span></tt></table><h2 id=options>Les options</h2><p>On peut appliquer une ou plusieurs options simultanément au début d'une expression avec <tt>…)</tt>, en cours de route avec <tt>(?…)</tt>, ou à un groupe isolé avec <tt>(?…:regex)</tt>. Le signe <tt>-</tt> placé devant une option la désactive.<table cellspacing="0"><tr><th>Option<th>Explication<th>Exemple<tr class=impair><td><tt>i</tt><td>Rend l'expression rationnelle insensible à la casse.<td><tt class=regex>i)abc</tt> trouve aussi bien <tt class=match>abc</tt> que <tt class=match>ABC</tt><tr><td><tt>m</tt><td>Fait correspondre les ancres <tt>^</tt> et <tt>$</tt> aux extémités de chaque ligne, en plus de celles de la chaîne.<td><tt class=regex>m)^abc$</tt> trouve <tt class=match>abc</tt> aussi bien dans <tt class=string>abc</tt> que dans <tt class=string>123\r\nabc\r\n456</tt><tr class=impair><td><tt>s</tt><td>Rend le point <tt>.</tt> capable de correspondre à tout caractère, y compris ceux de fin de ligne.<td><tt class=regex>s)a..</tt> trouve aussi bien <tt class=match>abc</tt> que <tt class=match>a\r\n</tt>, mais <tt class=regex>a..</tt> ne trouverait pas <tt class=nomatch>a\r\n</tt><tr><td><tt>x</tt><td>Permet d'utiliser espace, tab et fin de ligne pour indenter l'expression, et autorise l'inclusion de commentaires <tt>(?#…)</tt>.<td><pre><tt class=regex>x)\d{3}</tt> <tt>(?# Cherche un nombre à 3 chiffres)</tt>    
    <tt class=regex>abc</tt> <tt>(?# Suivi des lettres a, b et c)</tt></pre><tr class=impair><td><tt>A</tt><td>Ancre le motif au début de la chaîne, strictement. Équivaut à <tt class=regex>\A</tt>.<td><tt class=regex>A)abc</tt> trouve <tt class=match>abc</tt> dans <tt class=string>abc123</tt>, mais pas dans <tt class=nomatch>\nabc123</tt><tr><td><tt>D</tt><td>Force le <tt>$</tt> à correspondre à la fin de la chaîne strictement. Cette option est ignorée lorsque l'option <tt>m</tt> est activée.<td><tt class=regex>D)abc$</tt> trouve <tt class=match>abc</tt> dans <tt class=string>123abc</tt>, mais pas dans <tt class=nomatch>123abc\r\n</tt><tr class=impair><td><tt>U</tt><td>Rend les quantificateurs voraces frugaux, et les quantificateurs frugaux voraces.<td><tt class=regex>U)a.+c</tt> trouve <tt class=match>abc</tt> dans <tt class=string>abc123c</tt>, alors que <tt class=regex>a.+c</tt> trouverait <tt class=match>abc123c</tt></table><h2 id=renvois>Les renvois</h2><table cellspacing="0"><tr><th>Forme<th>Explication<th>Exemple<tr class=impair><td><tt>$1</tt><td>Restitue la correspondance d'un groupe numéroté. Écrire <tt>${10}</tt> lorsque le numéro est supérieur à 9. Enfin, <tt>$0</tt> restitue la correspondance complète.<td>Si <tt class=regex>([a-c]{3})\d+</tt> et <tt class=string>abc123</tt>; alors <tt class=regex>$1</tt> restitue <tt class=match>abc</tt>, mais <tt class=regex>$0</tt> restitue <tt class=match>abc123</tt><tr><td><tt>${nom}</tt><td>Restitue la correspondance d'un goupe nommé. Le groupe est nommé avec <tt>&lt;></tt>, mais appelé avec <tt>{}</tt>.<td>Si <tt class=regex>.+?(?P&lt;nb>\d+)</tt> et <tt class=string>abc123</tt>; alors <tt class=regex>${nb}</tt> restitue <tt class=match>123</tt><tr class=impair><td><tt>$L1</tt><td>Restitue en bas de casse la correspondance d'un groupe numéroté. <tt>$U1</tt> restitue en haut de casse, et <tt>$T1</tt> met l'initiale de chaque mot en majuscule. Les lettres <tt>lut</tt> fonctionnent aussi.<td><tt class=regex>i)#([A-F0-9]{6})</tt> trouve <tt class=match>#d4d0c8</tt>, mais <tt class=regex>#$U1</tt> ou <tt class=regex>#$u1</tt> restitue <tt class=match>#D4D0C8</tt></table><h2 id=comportements>Les comportements</h2><p>Une expression a un comportement <b>vorace</b> lorsqu'elle absorbe le maximum de caractères avant de rebrousser chemin et d'en laisser tomber pour tenter d'établir une correspondance avec une chaîne plus courte. Par exemple : <tt class=regex>«.+»</tt> appliquée à <tt class=string>abc «def» «ghi» jkl</tt> :<ol><li>établit d'abord la correspondance entre <tt class=regex>«</tt> et <tt class=match>«</tt>;<li>répète <tt class=regex>.+</tt> autant de fois que possible et finit par absorber <tt class=match>def» «ghi» jkl</tt>;<li>rebrousse chemin vers <tt class=regex>.+</tt> après avoir échoué à établir une correspondance entre <tt class=regex>»</tt> la fin de la chaîne;<li>régresse d'un caractère à la fois en tentant d'établir cette correspondance;<li>arrête sa régression dès que la correspondance est établie entre <tt class=regex>»</tt> et <tt class=match>»</tt>;<li>retourne <tt class=match>«def» «ghi»</tt> comme première correspondance complète trouvée.</ol><p>Une expression a un comportement <b>frugal</b> lorsqu'elle absorbe le minimum de caractères requis avant de rebrousser chemin et d'en absorber davantage pour tenter d'établir une correspondance avec une chaîne plus longue. Par exemple : <tt class=regex>«.+?»</tt> appliquée à <tt class=string>abc «def» «ghi» jkl</tt> :<ol><li>établit d'abord la correspondance entre <tt class=regex>«</tt> et <tt class=match>«</tt>;<li>répète <tt class=regex>.+?</tt> le moins de fois possible, c'est-à-dire une seule, et absorbe seulement <tt class=match>d</tt>;<li>rebrousse chemin vers <tt class=regex>.+?</tt> après avoir échoué à établir une correspondance entre <tt class=regex>»</tt> la suite de la chaîne;<li>progresse d'un caractère à la fois en tentant d'établir cette correspondance;<li>arrête sa progression dès que la correspondance est établie entre <tt class=regex>»</tt> et <tt class=match>»</tt>;<li>retourne <tt class=match>«def»</tt> comme première correspondance complète trouvée.</ol><p>Une expression a un comportement <b>possessif</b> lorsqu'elle ne permet pas de rebrousser chemin vers une partie antérieure de l'expression pour tenter d'établir une correspondance avec une une chaîne différente. Par exemple : <tt class=regex>«.++»</tt> appliquée à <tt class=string>abc «def» «ghi» jkl</tt> :<ol><li>établit d'abord la correspondance entre <tt class=regex>«</tt> et <tt class=match>«</tt>;<li>répète <tt class=regex>.++</tt> autant de fois que possible et finit par absorber <tt class=match>def» «ghi» jkl</tt>;<li>ne rebrousse pas chemin vers <tt class=regex>.++</tt> après avoir échoué à établir une correspondance entre <tt class=regex>»</tt> la fin de la chaîne;<li>retourne qu'aucune correspondance complète n'a pu être trouvée.</ol>